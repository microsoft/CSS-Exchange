# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

. $PSScriptRoot\..\..\..\..\Shared\Get-RemoteRegistryValue.ps1

function Invoke-OutsideInModuleAction {
    [CmdletBinding(DefaultParameterSetName = "ConfigureOutsideIn", ConfirmImpact = 'High')]
    param(
        [Parameter(Mandatory = $true, ParameterSetName = "ConfigureOutsideIn")]
        [Parameter(Mandatory = $true, ParameterSetName = "ConfigureFileTypes")]
        [ValidateSet("ConfigureOutsideIn", "ConfigureFileTypes")]
        [string]$Configuration,

        [Parameter(Mandatory = $true, ParameterSetName = "ConfigureFileTypes")]
        [object]$FileTypesDictionary,

        [Parameter(Mandatory = $true, ParameterSetName = "ConfigureOutsideIn")]
        [Parameter(Mandatory = $true, ParameterSetName = "ConfigureFileTypes")]
        [ValidateSet("Allow", "Block")]
        [string]$Action
    )

    begin {
        Write-Verbose "Calling: $($MyInvocation.MyCommand)"

        function GetFipFsConfigurationPath {
            param(
                [string]$MachineName = $env:COMPUTERNAME
            )

            Write-Verbose "Calling: $($MyInvocation.MyCommand)"

            $fipFsDatabaseParams = @{
                MachineName = $MachineName
                SubKey      = "SOFTWARE\Microsoft\ExchangeServer\v15\FIP-FS"
                GetValue    = "DatabasePath"
            }

            Write-Verbose "Trying to detect FIP-FS database path for machine: $MachineName"
            $fipFsDatabasePath = Get-RemoteRegistryValue @fipFsDatabaseParams

            if (-not[System.String]::IsNullOrWhiteSpace($fipFsDatabasePath)) {
                Write-Verbose "FIP-FS database path is: $fipFsDatabasePath"
                return (Join-Path $fipFsDatabasePath "Configuration.xml")
            } else {
                Write-Verbose "Unable to read FIP-FS database path from registry"
                return $null
            }
        }

        function BackupFipFsConfiguration {
            param(
                [string]$FipFsConfigurationPath
            )

            Write-Verbose "Calling: $($MyInvocation.MyCommand)"
            $backupTimestamp = Get-Date -Format yyyyMMddmmss

            if (Test-Path -Path $FipFsConfigurationPath) {
                Write-Verbose "FIP-FS configuration file detected"
                $configurationBackupPath = $FipFsConfigurationPath + ".$backupTimestamp" + ".bak"
                Copy-Item -Path $FipFsConfigurationPath -Destination $configurationBackupPath

                Write-Verbose "Backup configuration is: $configurationBackupPath"
                return $true
            } else {
                Write-Verbose "FIP-FS configuration file doesn't exist"
                return $false
            }
        }

        function StartStopFipFsDependendServices {
            param(
                [ValidateSet("Start", "Stop")]
                [string]$ServiceAction
            )

            Write-Verbose "Calling: $($MyInvocation.MyCommand)"
            try {
                if ($ServiceAction -eq "Stop") {
                    Write-Verbose "Stopping MSExchangeTransport and FMS services..."
                    Stop-Service -Name "FMS" -Force
                } else {
                    Write-Verbose "Starting MSExchangeTransport and FMS services..."
                    Start-Service -Name "MSExchangeTransport"
                    Start-Service -Name "FMS"
                }
            } catch {
                Write-Verbose "We hit an exception while performing services action: $ServiceAction"
                Write-Verbose "Exception: $_"

                return $false
            }

            return $true
        }

        function SetConfigurationAttribute {
            [CmdletBinding(DefaultParameterSetName = "ConfigureOutsideIn", SupportsShouldProcess = $true, ConfirmImpact = 'High')]
            param(
                [Parameter(Mandatory = $true, ParameterSetName = "ConfigureOutsideIn")]
                [Parameter(Mandatory = $true, ParameterSetName = "ConfigureFileTypes")]
                [object[]]$Nodes,

                [Parameter(Mandatory = $false, ParameterSetName = "ConfigureOutsideIn")]
                [Parameter(Mandatory = $false, ParameterSetName = "ConfigureFileTypes")]
                [ValidateSet("ConfigureOutsideIn", "ConfigureFileTypes")]
                [string]$ConfigurationMode = "ConfigureOutsideIn",

                [Parameter(Mandatory = $true, ParameterSetName = "ConfigureFileTypes")]
                [object]$FileTypes,

                [Parameter(Mandatory = $false, ParameterSetName = "ConfigureOutsideIn")]
                [string]$ModuleToConfigure = "OutsideInModule.dll",

                [Parameter(Mandatory = $false, ParameterSetName = "ConfigureOutsideIn")]
                [Parameter(Mandatory = $false, ParameterSetName = "ConfigureFileTypes")]
                [bool]$Enabled = $false
            )

            Write-Verbose "Calling: $($MyInvocation.MyCommand)"
            # Configuration strings are case sensitive and must be set to lowercase true or false
            $modulesEnabledValue = if ($Enabled) { "true" } else { "false" }

            if ($ConfigurationMode -eq "ConfigureFileTypes") {
                # We need to clone a node just in case that we need to add file types back to the allowed list
                $nodeCloneTemplace = ($Nodes.Node | Where-Object { $null -ne $_.Type } | Select-Object -First 1).CloneNode($true)
            }

            foreach ($n in $Nodes) {
                $fileTypesEntry = $null
                if ($ConfigurationMode -eq "ConfigureFileTypes") {

                    $fileTypesEntry = $FileTypes["$($n.Node.Name)"]
                    if ($Enabled -eq $false) {
                        # We are removing the specified file types here
                        if ($null -ne $fileTypesEntry) {
                            Write-Verbose "AllowedType: $($n.Node.Name) found - checking for FileType entries now..."
                            $n.Node.Type | Where-Object {
                                $_.Name -in $fileTypesEntry
                            } | ForEach-Object {
                                Write-Verbose "FileType: $($n.Node.Type) is on the allow list and will be removed now"
                                [void]($_.ParentNode.RemoveChild($_))
                            }
                        } else {
                            Write-Verbose "AllowedType: $($n.Node.Name) not found and will be skipped"
                        }
                    } else {
                        # We will explicitly enable the specified file types here
                        if ($null -ne $fileTypesEntry) {
                            Write-Verbose "AllowedType: $($n.Node.Name) found - checking for FileType entries now..."
                            $fileTypesEntry | ForEach-Object {
                                if ($n.Node.Type.Name -notcontains $_) {
                                    Write-Verbose "FileType: $_ will be added to the allow list"
                                    $nodeClone = $nodeCloneTemplace.Type.CloneNode($true)
                                    $nodeClone.Name = "$_"
                                    $n.Node.AppendChild($nodeClone)
                                } else {
                                    Write-Verbose "FileType: $_ is already on the allow list and will be skipped"
                                }
                            }
                        }
                    }
                } elseif ($ConfigurationMode -eq "ConfigureOutsideIn") {
                    # We explicitly enable or disable the OutsideInModule here
                    if ($n.Node.InnerText.StartsWith($ModuleToConfigure)) {
                        Write-Verbose "Setting module: $($n.Node.InnerText) to Enabled: $Enabled"
                        $n.Node.Attributes["Enabled"].Value = $modulesEnabledValue
                    } else {
                        Write-Verbose "Module: $($n.Node.InnerText) will be skipped as it's not related to: $ModuleToConfigure"
                    }
                }
            }
        }

        function PerformFipFsConfigurationOperation {
            [CmdletBinding(DefaultParameterSetName = "ConfigureOutsideIn", ConfirmImpact = 'High')]
            param(
                [Parameter(Mandatory = $true, ParameterSetName = "ConfigureOutsideIn")]
                [Parameter(Mandatory = $true, ParameterSetName = "ConfigureFileTypes")]
                [string]$FipFsConfigurationPath,

                [Parameter(Mandatory = $true, ParameterSetName = "ConfigureOutsideIn")]
                [Parameter(Mandatory = $true, ParameterSetName = "ConfigureFileTypes")]
                [ValidateSet("DisableOutsideIn", "EnableOutsideIn", "BlockVulnerableFileTypes", "AllowVulnerableFileTypes")]
                [string]$Operation,

                [Parameter(Mandatory = $true, ParameterSetName = "ConfigureFileTypes")]
                [object]$FileTypesDictionary
            )

            begin {
                Write-Verbose "Calling: $($MyInvocation.MyCommand)"

                $configXmlNamespaces = @{
                    root = "http://schemas.microsoft.com/forefront/2010/1/fs-configuration"
                    sys  = "http://schemas.microsoft.com/forefront/2010/1/fs-systemconfiguration"
                }
                $modulePath = "/root:Configuration/sys:System/sys:TextExtractionSettings/sys:ModuleLists/sys:ModuleList/sys:Module"
                $typePath = "/root:Configuration/sys:System/sys:TextExtractionSettings/sys:TypeLists/sys:TypeList"
            } process {
                # Stopping MSExchangeTransport and FMS services
                if (StartStopFipFsDependendServices -ServiceAction "Stop") {
                    # Perform backup of the existing configuration.xml
                    if (BackupFipFsConfiguration -FipFsConfigurationPath $FipFsConfigurationPath) {
                        try {
                            [xml]$configuration = Get-Content -Path $FipFsConfigurationPath

                            # Based on how blocking will be done, we need the corresponding path
                            if ($Operation -eq "DisableOutsideIn" -or
                                $Operation -eq "EnableOutsideIn") {

                                # We use this to completely block the OutsideInModule
                                $modules = $configuration | Select-Xml -Namespace $configXmlNamespaces -XPath $modulePath

                                # Perform the action based on the value that was passed via Operation parameter
                                $outsideInParams = @{
                                    Nodes   = $modules
                                    Enabled = if ( $Operation -eq "DisableOutsideIn") { $false } else { $true }
                                }
                                SetConfigurationAttribute @outsideInParams
                            } elseif ($Operation -eq "BlockVulnerableFileTypes" -or
                                $Operation -eq "AllowVulnerableFileTypes") {

                                # We use this to partially blocking the vulnerable file types
                                $types = $configuration | Select-Xml -Namespace $configXmlNamespaces -XPath $typePath
                                $fileTypeParams = @{
                                    Nodes             = $types
                                    ConfigurationMode = "ConfigureFileTypes"
                                    FileTypes         = $FileTypesDictionary
                                    Enabled           = if ($Operation -eq "BlockVulnerableFileTypes") { $false } else { $true }
                                }
                                SetConfigurationAttribute @fileTypeParams
                            }
                        } catch {
                            Write-Verbose "We hit an exception while processing the change to the configuration.xml. Please run the script again."
                            Write-Verbose "Exception: $_"
                        }
                    } else {
                        Write-Verbose "We fail to create a backup of the configuration.xml file. Please run the script again."
                    }
                } else {
                    Write-Verbose "We fail to stop the MSExchangeTransport and FMS services. Please run the script again."
                }
            } end {
                # Save the modified FIP-FS configuration.xml and restart the MSExchangeTransport and FMS services
                $configuration.Save($FipFsConfigurationPath)
                StartStopFipFsDependendServices -ServiceAction "Start"
            }
        }
    } end {
        $fipsOperationParams = @{
            FipFsConfigurationPath = GetFipFsConfigurationPath
        }

        if ($Configuration -eq "ConfigureFileTypes") {
            $fipsOperationParams.Add("FileTypesDictionary", $FileTypesDictionary)
            $fipsOperationParams.Add("Operation", $(if ($Action -eq "Allow") { "AllowVulnerableFileTypes" } else { "BlockVulnerableFileTypes" }))
        } else {
            $fipsOperationParams.Add("Operation", $(if ($Action -eq "Allow") { "EnableOutsideIn" } else { "DisableOutsideIn" }))
        }

        PerformFipFsConfigurationOperation @fipsOperationParams
    }
}
