# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

. $PSScriptRoot\..\Helpers\Get-ExportedHealthCheckerFiles.ps1
# This function is used to collect the data from the entire environment for vulnerabilities.
# This will still use the entire data collection process that is handled within the main HC data collection
# However, it will not display it on the screen and just analyze the data and pull out the data that we want.
function Invoke-VulnerabilityReport {

    Write-Verbose "Calling: $($MyInvocation.MyCommand)"
    $currentErrors = $Error.Count

    if ((-not $SkipVersionCheck) -and
                (Test-ScriptVersion -AutoUpdate -VersionsUrl "https://aka.ms/HC-VersionsUrl")) {
        Write-Yellow "Script was updated. Please rerun the command."
        return
    } else {
        $Script:DisplayedScriptVersionAlready = $true
        Write-Green "Exchange Health Checker version $BuildVersion"
    }

    Invoke-ErrorCatchActionLoopFromIndex $currentErrors
    $stopWatch = [System.Diagnostics.Stopwatch]::StartNew()
    Set-ADServerSettings -ViewEntireForest $true
    $exchangeServers = @(Get-ExchangeServer)
    Write-Verbose "Took $($stopWatch.Elapsed.TotalSeconds) seconds to run Get-ExchangeServer"
    Write-Verbose "Found $($exchangeServers.Count) Exchange Servers"

    $healthCheckerData = New-Object System.Collections.Generic.List[object]
    $serverNames = New-Object System.Collections.Generic.List[string]
    $exchangeServers | ForEach-Object { $serverNames.Add($_.Name.ToLower()) }

    # By default, always try to import the local data and see if we can use it.
    # This is determined by the files being the same version as the current version of the script.
    $importData = Get-ExportedHealthCheckerFiles -Directory $XMLDirectoryPath

    if ($null -ne $importData) {
        $importData |
            Where-Object { $_.HealthCheckerExchangeServer.HealthCheckerVersion -eq $BuildVersion } |
            ForEach-Object {
                $name = $_.HealthCheckerExchangeServer.ServerName.Split(".")[0].ToLower()
                Write-Verbose "Server $name is being imported"
                $healthCheckerData.Add($_)
                # Remove it from the list
                $serverNames.Remove($name) | Out-Null
            }
        Write-Verbose "Imported $($healthCheckerData.Count) server data to save time"
    } else {
        Write-Verbose "No data was imported."
    }

    # We may have imported all the files required, therefore, we can skip attempting to import the data.
    if ($serverNames.Count -gt 0) {
        Get-HealthCheckerData -ServerNames $serverNames -EdgeServer $false -ReturnDataCollectionOnly $true |
            ForEach-Object {
                $healthCheckerData.Add($_)
            }
    }

    Write-Verbose "Took $($stopWatch.Elapsed.TotalSeconds) seconds to get all the Health Checker data"
    $serverVulnerabilityReport = New-Object System.Collections.Generic.List[object]

    foreach ($exchServer in $exchangeServers) {
        $serverName = $exchServer.Name
        Write-Verbose "Working on server $($serverName)"
        $serverData = $healthCheckerData | Where-Object { $_.HealthCheckerExchangeServer.ExchangeInformation.GetExchangeServer.Name -eq $serverName }
        $vulnerabilityList = New-Object System.Collections.Generic.List[object]
        $buildVersionInfo = Get-ExchangeBuildVersionInformation -AdminDisplayVersion $exchServer.AdminDisplayVersion

        if ($null -ne $serverData) {
            $hc = $serverData.HealthCheckerExchangeServer
            $serverName = $hc.ServerName
            $buildVersionInfo = $hc.ExchangeInformation.BuildInformation.VersionInformation
            $securityKey = [array]@($serverData.DisplayResults.Keys) | Where-Object { $_.Name -eq "Security Vulnerability" }

            foreach ($vulnerability in $serverData.DisplayResults[$securityKey]) {
                $securityVulnerability = "Security Vulnerability"
                $iisModule = "IIS module anomalies detected"
                $cveName = [string]::Empty

                if ($vulnerability.Name -eq $securityVulnerability) {
                    if ($vulnerability.CustomName -ne $securityVulnerability) {
                        $cveName = $vulnerability.CustomName
                    } else {
                        $cveName = $vulnerability.CustomValue
                    }
                } elseif (($vulnerability.Name -eq $iisModule -and
                        $vulnerability.CustomValue -eq $true) -or
                    ($null -ne $vulnerability.Name -and
                    $vulnerability.Name -ne $iisModule)) {
                    $cveName = $vulnerability.Name
                } else {
                    Write-Verbose "Failed to determine Security Vulnerability match"
                }

                if ($cveName -ne [string]::Empty) {
                    $vulnerabilityList.Add($cveName)
                }
            }
        } else {
            Write-Verbose "Didn't get Health Checker Data"
        }

        $hasVulnerability = "Unknown"
        $online = $null -ne $serverData

        if ($online) {
            $hasVulnerability = $vulnerabilityList.Count -gt 0
        }

        $serverVulnerabilityReport.Add([PSCustomObject]@{
                Name             = $serverName
                BuildVersion     = $buildVersionInfo.BuildVersion.ToString()
                HasVulnerability = $hasVulnerability
                Vulnerabilities  = $vulnerabilityList
                Online           = $online
            })
    }

    $vulnerabilityReport = [PSCustomObject]@{
        VersionReport = $BuildVersion
        ReportDate    = (Get-Date).ToString()
        Organization  = $healthCheckerData[0].HealthCheckerExchangeServer.OrganizationInformation.GetOrganizationConfig.DistinguishedName
        Servers       = $serverVulnerabilityReport
    }

    $outputFile = "$($Script:OutputFilePath)\HealthChecker-VulnerabilityReport-$($Script:dateTimeStringFormat).json"
    $vulnerabilityReport | ConvertTo-Json -Depth 3 | Out-File $outputFile
    Write-Verbose "Took $($stopWatch.Elapsed.TotalSeconds) seconds to complete vulnerability report."
    Write-Host "Report written to $outputFile"
}
