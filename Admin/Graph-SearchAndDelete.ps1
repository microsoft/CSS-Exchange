# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

#
# Graph-SearchAndDelete.ps1
#
# By Jim Martin, Microsoft Ltd. 2013-2023. Use at your own risk.  No warranties are given.
#
#  DISCLAIMER:
# THIS CODE IS SAMPLE CODE. THESE SAMPLES ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.
# MICROSOFT FURTHER DISCLAIMS ALL IMPLIED WARRANTIES INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR OF FITNESS FOR
# A PARTICULAR PURPOSE. THE ENTIRE RISK ARISING OUT OF THE USE OR PERFORMANCE OF THE SAMPLES REMAINS WITH YOU. IN NO EVENT SHALL
# MICROSOFT OR ITS SUPPLIERS BE LIABLE FOR ANY DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
# BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE THE
# SAMPLES, EVEN IF MICROSOFT HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. BECAUSE SOME STATES DO NOT ALLOW THE EXCLUSION OR LIMITATION
# OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES, THE ABOVE LIMITATION MAY NOT APPLY TO YOU.

param(
    [Parameter(Mandatory = $false, HelpMessage = "The AppCredentialType parameter specifies whether to use a client secret or certificate.")][ValidateSet('ClientSecret', 'Certificate')] [string]$AppCredentialType = "ClientSecret",
    [Parameter(Mandatory = $true, HelpMessage = "The Mailbox parameter specifies the mailbox to perform the search against.")] [string]$Mailbox,
    [Parameter(Mandatory = $false, HelpMessage = "The CreatedBefore parameter searches for only messages created before this date.")] [datetime]$CreatedBefore,
    [Parameter(Mandatory = $false, HelpMessage = "The CreatedAfter parameter searches for only messages created after this date.")] [datetime]$CreatedAfter,
    [Parameter(Mandatory = $False, HelpMessage = "The Subject parameter searches for only messages containing this string in the subject.")] [string]$Subject,
    [Parameter(Mandatory = $False, HelpMessage = "The Sender parameter searches for only messages sent by this sender.")] [string]$SenderAddress,
    [Parameter(Mandatory = $False, HelpMessage = "The MessageBody parameter specifies the body string used by the search.")] [string]$MessageBody,
    [Parameter(Mandatory = $true, HelpMessage = "The OutputPath parameter specifies the path for report generated by the script.")] [string]$OutputPath,
    [Parameter(Mandatory = $False, HelpMessage = "The DeleteContent parameter is a switch to delete the items found in the search results (moved to Deleted Items).")][switch]$DeleteContent,
    [Parameter(Mandatory = $false, HelpMessage = "The SearchDumpster parameter is a switch to search the recoverable items.")] [switch]$SearchDumpster,
    [Parameter(Mandatory = $False, HelpMessage = "The IncludeFolderList parameter specifies the folder(s) to be searched (if not present, then the Inbox folder will be searched).  Any exclusions override this list.")] $IncludeFolderList,
    [Parameter(Mandatory = $False, HelpMessage = "The ExcludeFolderList parameter specifies the folder(s) to be excluded (these folders will not be searched).")] $ExcludeFolderList,
    [Parameter(Mandatory = $False, HelpMessage = "The ProcessSubfolders parameter is a switch to enable searching the subfolders of any specified folder.")] [switch]$ProcessSubfolders,
    
    #>** OAUTH PARAMETERS START **#
    [Parameter(Mandatory = $False, HelpMessage = "The OAuthClientId specifies the client Id that this script will identify as.  Must be registered in Azure AD.")] [string]$OAuthClientId = "",
    [Parameter(Mandatory = $False, HelpMessage = "The OAuthTenantId specifies the tenant Id (application must be registered in the same tenant being accessed).")] [string]$OAuthTenantId = "",
    [Parameter(Mandatory = $False, HelpMessage = "The OAuthRedirectUri specifies the redirect Uri of the Azure registered application.")] [string]$OAuthRedirectUri = "",
    [Parameter(Mandatory = $False, HelpMessage = "The OAuthSecretKey specifies the secret key if using application permissions.")] [string]$OAuthSecretKey = "",
    [Parameter(Mandatory = $False, HelpMessage = "The OAuthCertificate specifies the certificate if using application permissions.  Certificate auth requires MSAL libraries to be available.")] $OAuthCertificate = $null,
    #>** OAUTH PARAMETERS END **#
    [Parameter(Mandatory = $False, HelpMessage = "The LogFile parameter specifies the Log file path - activity is logged to this file if specified.")][string]$LogFile = "",
    [Parameter(Mandatory = $False, HelpMessage = "The VerboseLogFile parameter is a switch that enables verbose log file.  Verbose logging is written to the log whether -Verbose is enabled or not.")]	[switch]$VerboseLogFile,
    [Parameter(Mandatory = $False, HelpMessage = "The DebugLogFile parameter is a switch that enables debug log file.  Debug logging is written to the log whether -Debug is enabled or not.")][switch]$DebugLogFile,
    [Parameter(Mandatory = $False, HelpMessage = "The FastFileLogging parameter is a switch that if selected, an optimised log file creator is used that should be signficantly faster (but may leave file lock applied if script is cancelled).")][switch]$FastFileLogging
    
)

#>** LOGGING FUNCTIONS START **#
function LogToFile([string]$Details) {
    if ( [String]::IsNullOrEmpty($LogFile) ) { return }
    "$([DateTime]::Now.ToShortDateString()) $([DateTime]::Now.ToLongTimeString())   $Details" | Out-File $LogFile -Append
}

function UpdateDetailsWithCallingMethod([string]$Details) {
    # Update the log message with details of the function that logged it
    $timeInfo = "$([DateTime]::Now.ToShortDateString()) $([DateTime]::Now.ToLongTimeString())"
    $callingFunction = (Get-PSCallStack)[2].Command # The function we are interested in will always be frame 2 on the stack
    if (![String]::IsNullOrEmpty($callingFunction)) {
        return "$timeInfo [$callingFunction] $Details"
    }
    return "$timeInfo $Details"
}

function LogToFile([string]$logInfo) {
    if ( [String]::IsNullOrEmpty($LogFile) ) { return }
    
    if ($FastFileLogging) {
        # Writing the log file using a FileStream (that we keep open) is significantly faster than using out-file (which opens, writes, then closes the file each time it is called)
        $fastFileLogError = $Error[0]
        if (!$script:logFileStream) {
            # Open a filestream to write to our log
            Write-Verbose "Opening/creating log file: $LogFile"
            $script:logFileStream = New-Object IO.FileStream($LogFile, ([System.IO.FileMode]::Append), ([IO.FileAccess]::Write), ([IO.FileShare]::Read) )
            if ( $Error[0] -ne $fastFileLogError ) {
                $FastFileLogging = $false
                Write-Host "Fast file logging disabled due to error: $Error[0]" -ForegroundColor Red
                $script:logFileStream = $null
            }
        }
        if ($script:logFileStream) {
            if (!$script:logFileStreamWriter) {
                $script:logFileStreamWriter = New-Object System.IO.StreamWriter($script:logFileStream)
            }
            $script:logFileStreamWriter.WriteLine($logInfo)
            $script:logFileStreamWriter.Flush()
            if ( $Error[0] -ne $fastFileLogError ) {
                $FastFileLogging = $false
                Write-Host "Fast file logging disabled due to error: $Error[0]" -ForegroundColor Red
            }
            else {
                return
            }
        }
    }

    $logInfo | Out-File $LogFile -Append
}

function Log([string]$Details, [ConsoleColor]$Colour) {
    if ($Colour -eq $null) {
        $Colour = [ConsoleColor]::White
    }
    $Details = UpdateDetailsWithCallingMethod( $Details )
    Write-Host $Details -ForegroundColor $Colour
    LogToFile $Details
}
Log "$($MyInvocation.MyCommand.Name) version $($script:ScriptVersion) starting" Green

function LogVerbose([string]$Details) {
    Write-Verbose $Details
    #if ( !$VerboseLogFile -and !$DebugLogFile -and ($VerbosePreference -eq "SilentlyContinue") ) { return }
    LogToFile $Details
}

function LogDebug([string]$Details) {
    Write-Debug $Details
    if (!$DebugLogFile -and ($DebugPreference -eq "SilentlyContinue") ) { return }
    LogToFile $Details
}

$script:LastError = $Error[0]
function ErrorReported($Context) {
    # Check for any error, and return the result ($true means a new error has been detected)

    # We check for errors using $Error variable, as try...catch isn't reliable when remoting
    if ([String]::IsNullOrEmpty($Error[0])) { return $false }

    # We have an error, have we already reported it?
    if ($Error[0] -eq $script:LastError) { return $false }

    # New error, so log it and return $true
    $script:LastError = $Error[0]
    if ($Context) {
        Log "ERROR ($Context): $($Error[0])" Red
    }
    else {
        $log = UpdateDetailsWithCallingMethod("ERROR: $($Error[0])")
        Log $log Red
    }
    return $true
}

function ReportError($Context) {
    # Reports error without returning the result
    ErrorReported $Context | Out-Null
}
#>** LOGGING FUNCTIONS END **#

function CreateOutputFile {
    # Create the output file
    # If an Output path is defined via the parameter, first check if the provided Output Path exists, if not exit the script
    if (!(Test-Path -Path $OutputPath)) {
        Write-Error "The provided OutputPath does not exist, exiting script" -ForegroundColor Red
        exit
    }
    else {
        # The path exists, so creating the Output file
        $Script:OutputStream = New-Item -Path $OutputPath -Type file -Force -Name $($Script:FileName) -ErrorAction Stop -WarningAction Stop
        # Add the header to the csv file
        $strCSVHeader = $Script:csvOuput = "Sender,Subject,ReceivedDateTime,Folder"
        Add-Content $Script:OutputStream $strCSVHeader
    }
}

function Test-InstalledModules {
    #Test if the required module is installed, if not exit the script and print a help message
    if (-not (Get-InstalledModule -Name MSAL.PS -MinimumVersion 4.37.0.0)) {
        Write-Host "This script requires 'MSAL.PS' module with Minimum version 4.37.0.0" -ForegroundColor Red
        Write-Host "Please install the required 'MSAL.PS' module from the PSGallery repository by running command:" -ForegroundColor Red
        Write-Host "Install-Module -Name MSAL.PS -MinimumVersion '4.37.0.0' -Repository:PSGallery" -ForegroundColor Red
        exit
    }
}

function GetOAuthToken {
    Log "Obtaining access token to use for the Graph API calls." Cyan
    if ($null -notlike $OAuthCertificate) {
        $Script:OAuthToken = Get-MsalToken -ClientId $OAuthClientId -RedirectUri $RedirectUri -TenantId $OAuthTenantId -Scopes $Script:Scope -AzureCloudInstance AzurePublic -ClientCertificate (Get-Item Cert:\CurrentUser\My\$CertificateThumbprint)
    }
    else {
        $OAuthSecretKey = $OAuthSecretKey | ConvertTo-SecureString -Force -AsPlainText
        $Script:OAuthToken = Get-MsalToken -ClientId $OAuthClientId -ClientSecret $OAuthSecretKey -TenantId $OAuthTenantId -Scopes $Script:Scope -AzureCloudInstance AzurePublic
    }
    return $Script:OAuthToken.AccessToken
}

function Send-GraphRequest {
    param(
        [Parameter(Mandatory = $true, HelpMessage = "The Uri parameter specifies the request uri.")] [string] $Uri,
        [Parameter(Mandatory = $false, HelpMessage = "The HttpMethod parameter specifies the method for the request.")] [string] $HttpMethod = "GET"
    )
    if ($Script:OAuthToken.ExpiresOn -lt (Get-Date)) {
        Write-Host "Acquiring new token..." -ForegroundColor Cyan
        $Script:Token = GetOAuthToken
        $Headers = @{
            'Content-Type'  = "application\json"
            'Authorization' = "Bearer $Script:Token"
        }        
    }
    else {
        $Headers = @{
            'Content-Type'  = "application\json"
            'Authorization' = "Bearer $Script:Token"
        }
    }
    
    $MessageParams = @{
        "URI"             = $Uri
        "Headers"         = $Headers
        "Method"          = $HttpMethod
        "ContentType"     = "application/json"
        "UseBasicParsing" = $null
    }

    $Results = ""
    $StatusCode = ""

    do {
        try {
            $Results = Invoke-RestMethod @Messageparams
            $StatusCode = $Results.StatusCode
        }
        catch {
            $StatusCode = $_.Exception.Response.StatusCode.value__
            if ($StatusCode -eq 429) {
                Write-Warning "Request was throttled. Waiting for 60 seconds to retry..."
                Start-Sleep -Seconds 60
            }
            elseif ($StatusCode -eq 504) {
                Write-Warning "Request received timeout error. Waiting for 20 seconds to retry..."
                Start-Sleep -Seconds 20
            }
            else {
                Write-Error $_.Exception
            }
        }
    } 
    while ($StatusCode -eq 429)
    return $Results
}

function GetFolderList {
    Log "Getting a list of mail folders in the mailbox." Cyan
    if ($SearchDumpster) {
        $FolderResults = Send-GraphRequest -Uri "https://graph.microsoft.com/v1.0/users/$Mailbox/mailFolders/RecoverableItemsRoot/childfolders/?includeHiddenFolders=true"
    }
    else {
        $FolderResults = Send-GraphRequest -Uri "https://graph.microsoft.com/v1.0/users/$Mailbox/mailFolders/delta"
    }
    foreach ($Result in $FolderResults.Value) {
        $FolderList.Add($Result) | Out-Null
    }
    while ($null -ne $FolderResults.'@odata.nextLink') {
        $FolderResults = Send-GraphRequest -Uri $FolderResults.'@odata.nextLink'
        foreach ($Result in $FolderResults.Value) {
            $FolderList.Add($Result) | Out-Null
        }
    }
    if ($IncludeFolderList) {
        # We are searching specific folders
        foreach ($includedFolder in $IncludeFolderList) {
            $folder = GetFolder -IncludeFolder $includedFolder
            if ($folder) {
                $Script:SearchFolderList.Add($folder) | Out-Null
            }
        }
        if ($ProcessSubfolders) {
            foreach ($folder in $FolderList) {
                if ($folder.parentFolderId -eq $Script:ParentFolder) {
                    $Script:SearchFolderList.Add($folder) | Out-Null
                }
            }
        }
    }
    else {
        $Script:SearchFolderList = $FolderList
    }
    
    if ($ExcludeFolderList) {
        foreach ($excludedFolder in $ExcludeFolderList) {
            $folder = GetFolder -IncludeFolder $excludedFolder
            if ($folder) {
                $Script:SearchFolderList.Remove($folder)
            }
        }
    }
}
function GetFolder {
    param (
        [Parameter(Mandatory = $true)] [string]$IncludeFolder
    )
    foreach ($folder in $FolderList) {
        if ($folder.DisplayName -eq $IncludeFolder) {
            $Script:ParentFolder = $folder.id
            return $folder
        }
    }
}

function SearchMailbox {
    Log "Performing search against the mailbox..." Cyan
    foreach ($folder in $Script:SearchFolderList) {
        $Uri = "https://graph.microsoft.com/v1.0/users/$Mailbox/mailFolders/$($folder.id)/messages?"
        $UriFilter = CreateSearchQuery
    
        # Finalize the Uri with the final filter/search settings
        $Uri = $Uri + $UriFilter
        Log([string]::Format("Performing search against the {0} folder...", $folder.displayName))
        LogVerbose([string]::Format("Performing query using: {0}", $Uri))
    
        # Search the mailbox for items

        $SearchItems = Send-GraphRequest -Uri $Uri
        foreach ($Result in $SearchItems.Value) {
            $Script:SearchResults.Add($Result) | Out-Null
        }
        while ($null -ne $SearchItems.'@odata.nextLink') {
            $PageNumber = $PageNumber + $SearchItems.value.Count
            $SearchItems = Send-GraphRequest -Uri $SearchItems.'@odata.nextLink'
            foreach ($Result in $SearchItems.Value) {
                $Script:SearchResults.Add($Result) | Out-Null
            }
        }
    }
}

function CreateSearchQuery {
    if ($null -like $MessageBody) {
        LogVerbose "Creating a query using the filter function."
        if ($null -notlike $Subject) {
            $UriFilter = "filter=contains(subject,`'$Subject`')&`$top=500&`$from=$PageNumber"
        }
    
        if ($null -notlike $CreatedBefore) {
            $TempStartDate = [datetime]$CreatedBefore
            $TempStartDate = $TempStartDate.ToUniversalTime()
            $SearchStartDate = '{0:yyyy-MM-ddTHH:mm:ssZ}' -f $TempStartDate
            if ($UriFilter -like '*filter*') {
                $UriFilter = $UriFilter.Replace('filter=', "filter=receivedDateTime le $($SearchStartDate) and ")
            }
            else {
                $UriFilter = "filter=receivedDateTime le $($SearchStartDate)&`$top=500&`$from=$PageNumber"
            }
        }
    
        if ($null -notlike $CreatedAfter) {
            $TempEndDate = [datetime]$CreatedAfter
            $TempEndDate = $TempEndDate.ToUniversalTime()
            $SearchEndDate = '{0:yyyy-MM-ddTHH:mm:ssZ}' -f $TempEndDate
            if ($UriFilter -like '*filter*') {
                $UriFilter = $UriFilter.Replace('filter=', "filter=receivedDateTime ge $($SearchEndDate) and ")
            }
            else {
                $UriFilter = "filter=receivedDateTime ge $($SearchEndDate)&`$top=500&`$from=$PageNumber"
            }
        }
    
        if ($null -notlike $SenderAddress) {
            if ($UriFilter -like '*filter*') {
                $UriFilter = $UriFilter.Replace('filter=', "filter=(from/emailAddress/address) eq `'$SenderAddress`' and ")
            }
            else {
                $UriFilter = "filter=(from/emailAddress/address) eq `'$SenderAddress`'&`$top=500&`$from=$PageNumber"
            }
        }
    }
    else {
        # Build the search query based on specified parameters
        LogVerbose "Creating a query using the search function."
        $UriFilter = "`$search=`"body:$MessageBody`"&`$top=25"
    
        if ($null -notlike $SenderAddress) {
            if ($UriFilter -like '*search*') {
                $UriFilter = $UriFilter.Replace('search="', "search=`"from:$SenderAddress` AND ")
            }
            else {
                $UriFilter = "`$search=`"from:$SenderAddress`"&`$top=25"
            }
        }
    
        if ($null -notlike $Subject) {
            if ($UriFilter -like '*search*') {
                $UriFilter = $UriFilter.Replace('search="', "search=`"subject:$Subject` AND ")
            }
            else {
                $UriFilter = "`$search=`"subject:$Subject`"&`$top=1000&`$select=id,parentfolderid,receivedDateTime,subject,from&`$from=$PageNumber"
            }
        }
    
        if ($null -notlike $CreatedBefore) {
            $TempStartDate = [datetime]$CreatedBefore
            $TempStartDate = $TempStartDate.ToUniversalTime()
            $SearchBeforeDate = '{0:yyyy-MM-ddTHH:mm:ssZ}' -f $TempStartDate
            if ($UriFilter -like '*search*') {
                $UriFilter = $UriFilter.Replace('search="', "search=`"received<=$SearchBeforeDate AND ")
            }
            else {
                $UriFilter = "`$search=`"received<=$SearchBeforeDate`"&`$top=25"
            }
        }
    
        if ($null -notlike $CreatedAfter) {
            $TempStartDate = [datetime]$CreatedAfter
            $TempStartDate = $TempStartDate.ToUniversalTime()
            $SearchAfterDate = '{0:yyyy-MM-ddTHH:mm:ssZ}' -f $TempStartDate
            if ($UriFilter -like '*search*') {
                $UriFilter = $UriFilter.Replace('search="', "search=`"received>=$SearchAfterDate AND ")
            }
            else {
                $UriFilter = "`$search=`"received>=$SearchAfterDate`"&`$top=25"
            }
        }
    }
    return $UriFilter    
}

function BuildSearchReport {
    Log "Creating report with the search results." Cyan
    foreach ($result in $Script:SearchResults) {
        $FolderName = ($folderlist | Where-Object { $_.id -eq $result.parentFolderId }).displayName
        $Script:csvOuput = ($result.sender.emailaddress).address + "," + $result.Subject + "," + $result.receivedDateTime + "," + $FolderName
        Add-Content $Script:OutputStream $Script:csvOuput
    }    
}

function ProcessItems {
    Log "Deleting items found within the search results." Green
    foreach ($item in $Script:SearchResults) {
        $Uri = "https://graph.microsoft.com/v1.0/users/$Mailbox/messages/$($item.id)"
        Send-GraphRequest -Uri $Uri -HttpMethod DELETE | Out-Null
    }
}

###################################
# Declaring Script wide Variables #
###################################

$Date = [DateTime]::Now
$Script:StartTime = '{0:MM/dd/yyyy HH:mm:ss}' -f $Date
$Script:FileName = "GraphSearchAndDelete_$('{0:MMddyyyyHHmms}' -f $Date).csv"
$Script:Scope = "https://graph.microsoft.com/.default"
[int]$PageNumber = 0
$FolderList = New-Object System.Collections.ArrayList
$Script:SearchResults = New-Object System.Collections.ArrayList
$Script:SearchFolderList = New-Object System.Collections.ArrayList

$Uri = "https://graph.microsoft.com/v1.0/users/$Mailbox/mailFolders/messages?"

# Call function to confirm required PowerShell module(s) are installed
Test-InstalledModules

# Call function to create the output file and stream
CreateOutputFile

# Call function to obtain OAuth token
$Script:Token = GetOAuthToken

# Obtain list of mail folders within the mailbox
GetFolderList
#$FolderList | Format-Table displayName,id 

# Perform the search against the mailbox
SearchMailbox

# Build a report of the items
BuildSearchReport
Log([string]::Format("{0} message(s) found using the provided search filters.", $Script:SearchResults.Count)) Green

# Delete the items found using the search criteria
if ($DeleteContent) {
    ProcessItems
}
